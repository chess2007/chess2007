\ локально-именованные слова, переменные, массивы, строки, макросы, замыкания 

CREATE lcode 0x10000 ALLOT lcode VALUE dpl    \ область кода для слов с локальными именами
CREATE ldata 0x10000 ALLOT ldata VALUE ldhere \ область данных для локально-именованных переменных и массивов
VARIABLE XHERE  VARIABLE xdpl                 \ переменные сохранения указателей компиляции 

\ область локальных имен
0x100 CONSTANT lenlvoc
USER-CREATE alvoc lenlvoc USER-ALLOT 0 alvoc C!
VARIABLE lhere  
VARIABLE axtloc 

: lvoc ( -- a len )  alvoc lenlvoc ;  lvoc ERASE  1 lhere !

\ формирование локального имени ( после последнего символа имени идет 0-й байт )
: lname, ( a u -- axt)
  TUCK lhere @ SWAP MOVE lhere @ + DUP 0! 1+ DUP lhere ! DUP axtloc ! ;

: L{  dpl xdpl ! DP @ XHERE ! dpl DP ! ;         \ переключение на компиляцию в область lcode
: }L  dpl DP @ xdpl @ - + TO dpl XHERE @ DP ! ;  \ переключение на компиляцию в область CODE

: init-lvoc  lvoc ERASE lvoc DROP lhere ! ;      \ удаление локального словаря в части локальных имен, код лок. слов не удаляется
: headl  ( a u --  ) lname, dpl SWAP ! lhere @ 5 +  lhere !   ;

M: nf1-exit ( a u s  -- a u ) -ROT 2DUP + 1- C@ -ROT 2SWAP <> IF NOTFOUND EXIT THEN ;
M: nf2-exit ( a u ss -- a u ) -ROT 2DUP + 2- W@ -ROT 2SWAP <> IF NOTFOUND EXIT THEN ;

USER locxt 0 locxt ! \ XT для локально-именованного кода
USER iol 0 iol !     \ направление ввода-вывода в лок переменные типа value

: +: : ;             \ склеивание определений - локальный словарь не удаляется, слово определенное по +: добавляется в основной словарь
: : init-lvoc : ;

\ начало формирования кода с локальным именем
: NOTFOUND  ( a u -- )   '('  nf1-exit  1- headl L{ ;

\ окончание формирования кода с локальным именем
: ) ( -- )  RET, }L ; IMMEDIATE


\ локально-именованные  							   \ синтаксис
\ строки
: NOTFOUND  ( a u -- )   '"'  nf1-exit  1- headl L{ LOAD-TEXT            RET, }L ; \ name"  текст строки "
\ макросы 
: NOTFOUND  ( a u -- )   '['  nf1-exit  1- headl L{ LOAD-TEXT ` EVALUATE RET, }L ; \ name[  текст макроса ]
\ замыкания 
: NOTFOUND  ( a u -- )   '{'  nf1-exit  1- headl L{ LOAD-TEXT ` xts      RET, }L ; \ name{  текст замыкания }

\ окончание формирования кода с локальным именем, оставляющего токен на стеке
: x) ( -- )  RET, }L axtloc @ @ LIT, ; IMMEDIATE

\ процедура поиска имени в лок. словаре
: lsearch { a u a1 u1 \ a2 u2 fl -- a u 0|1 }           \
  0 TO fl BEGIN a u a1 u1 SEARCH >R TO u2 TO a2         \
                R> a2 u1 + C@ 0= a2 1- C@ 0= AND AND    \
                IF   1 TO fl a2 u1 TRUE                 \
                ELSE a2 u1 + 1+ TO a u2 u1 - 1- TO u    \
                     u u1 < IF 1 TO fl a u FALSE THEN   \
                THEN                                    \
       fl UNTIL  ;                                      \

: l' ( 'lname' -- xt ) TRUE locxt ! ; IMMEDIATE  \ аналог ' для локально-именованных слов

: is  1 iol ! ; IMMEDIATE  \ аналоги TO
: ib  2 iol ! ; IMMEDIATE
: iw  3 iol ! ; IMMEDIATE
: id  4 iol ! ; IMMEDIATE
: if  5 iol ! ; IMMEDIATE

\ компиляция кода с именами в лок. словаре
: NOTFOUND \ a u --
  OVER C@ '`' = IF 1 /STRING TRUE locxt ! THEN
  lvoc 2OVER  lsearch 0= lhere @ 1 = OR IF 2DROP NOTFOUND EXIT THEN
  2SWAP NIP NIP + 1+ @ iol @
  IF 12 + iol @ >R R@ 4 > IF 13 ELSE R@ 3 > IF  8 ELSE R@ 1 > IF 3 ELSE 0 THEN THEN THEN
     RDROP + 0 iol !
  THEN locxt @ 0= IF COMPILE, ELSE 0 locxt ! LIT, THEN  ;

\ локально-именованные переменые
: NOTFOUND ( a u --  ) \ типа 2variable variable wvariable bvariable
  ')' nf1-exit 1- headl  L{ ldhere FLIT, RET, ldhere 2 CELLS + TO ldhere }L ;
: NOTFOUND ( a u --  ) \ типа value
  '!' nf1-exit  1- headl ldhere LIT, ` !  L{ ldhere LIT, ` @ RET, ldhere LIT, ` ! RET,   ldhere 1 CELLS + TO ldhere }L ;
: NOTFOUND ( a u --  ) \ 2value
  '!d' nf2-exit  2- headl ldhere LIT, ` 2!  L{ ldhere LIT, ` 2@ RET, ldhere LIT, ` 2! RET, ldhere 2 CELLS + TO ldhere }L ;
: NOTFOUND ( a u --  ) \ 2value
  '!f' nf2-exit  2- headl ` FLOAT>DATA ldhere LIT, ` 2!  L{ ldhere LIT, ` 2@ ` DATA>FLOAT RET, ` FLOAT>DATA ldhere LIT, ` 2! RET, ldhere 2 CELLS + TO ldhere }L ;
: NOTFOUND ( a u --  ) \ wvalue
  '!w' nf2-exit  2- headl ldhere LIT, ` W!  L{ ldhere LIT, ` W@ RET, ldhere LIT, ` W! RET, ldhere 2+ TO ldhere }L ;
: NOTFOUND ( a u --  ) \ bvalue
  '!b' nf2-exit  2- headl ldhere LIT, ` C!  L{ ldhere LIT, ` C@ RET, ldhere LIT, ` C! RET, ldhere 1+ TO ldhere }L ;

\ локально-именованные статические массивы
: NOTFOUND ( a u --  ) \ размер задается только числовым литералом  20 arr]
  ']' nf1-exit OP0 @ 4 - @ >CS ` DROP  1-  headl  L{ ldhere LIT, RET, CS> ldhere + TO ldhere }L ;
: NOTFOUND ( a u --  ) \ размер берется с локального стека  $ 8 arr1} или [ величина >CS ] arr}
  '}' nf1-exit  1- headl  L{ ldhere LIT, RET, CS> ldhere + TO ldhere }L ;

\ разметка символами-суффиксами
: NOTFOUND ( a u -- ) u! a!  \ создать заголовок слова с переводом STATE в режим компиляции
  a u + 1- C@ ':' = u 1 > AND 0= IF a u NOTFOUND EXIT THEN
  init-lvoc a u 1- SHEADER 3 TO XN [begin] ] HIDE ;

: NOTFOUND ( a u -- ) u! a! 0 sa! \ исполнить слово или комбинатор независимо от STATE и от флага IMMEDIATE
  a u + 1- C@ '`' = u 1 > AND 0= IF a u NOTFOUND EXIT THEN
  a u 1- SFIND IF EXECUTE 
               ELSE lvoc 2SWAP lsearch  \ для локальных слов, определенных с использованием IMMEDIATE слов
                    IF   + 1+ @ EXECUTE 
                    ELSE a u 1- TYPE SPACE ." not found " CR 
                    THEN
               THEN ;

: NOTFOUND ( a u -- ) u! a!  \ скомпилировать слово или комбинатор независимо от STATE и от флага IMMEDIATE
  a u + 1- C@ ',' = u 1 > AND 0= IF a u NOTFOUND EXIT THEN
  a u 1- SFIND IF COMPILE, ELSE SLIT, POSTPONE EVALUATE THEN ;

: NOTFOUND ( a u -- ) u! a!  \ оставить XT слова
  a u + 1- C@ ''' = a C@ ''' <> AND u 1 > AND 0= IF a u NOTFOUND EXIT THEN
  a u 1- SFIND DROP STATE @ IF LIT, THEN ;

: NOTFOUND ( a u -- ) u! a!  \ хвостовая оптимизация кода слова
  a u + 1- C@ ';' = u 1 > AND 0= IF a u NOTFOUND EXIT THEN
  a u 1- SFIND DROP BRANCH, POSTPONE -; ;

\ неименованные замыкания
I: (c LOAD-TEXT ` xts RET, ;                  \ внутри определения (с ... с)
: C: : IMMEDIATE LOAD-TEXT ` xts POSTPONE ; ; \ определение слова-замыкания C: Name .... ;

\ числа с плавающей запятой в виде 3,141592
: NOTFOUND  ( a u -- )  u! a!  0. sq! sz! 0. pt! an!
  a u OVER + SWAP ?DO I C@ '0' ':' WITHIN IF sq 1+ is sq THEN  I C@ ',' = IF I a - is pt sz 1+ is sz THEN LOOP
  a C@ '-' = IF sq u 2- = ELSE sq u 1- = THEN sz 1 = AND 0= IF a u NOTFOUND EXIT THEN
  u 2+ ALLOCATE THROW is an a an u MOVE 'e' an u + C! '.' an pt + C! an u 1+ EVALUATE
; 

\EOF

Синтаксис локально-именованных слов

В рамках определения через двоеточие создается локальный словарь, который после компиляции кода определения удаляется в части очистки имен слов, 
код определения в части кода процедур, переменных и массивов, в том числе и их полей данных, остается.

6 VALUE Q1
: proc
  name( ..... )           \ создание процедуры с локальным именем name
  name                    \ исполнение процедуры 
  l' name ( -- xt)        \ получение xt процедуры
  `name   ( -- xt)        \ получение xt процедуры
  name( .... x) ( -- xt)  \ создание процедуры с выдачей xt,  само имя name не исполняется
  a)                      \ создание переменной типа VARIABLE с полем данных в 8 байт
  0  a  ! a  @            \ имя переменной выдает адрес поля данных переменной
  0. a 2! a 2@            \ с переменной возможны операции с разрядностью 8, 16, 32 и 64 бита
  0  a C! a C@
  0  a W! a W@
  0 b!                   \ создание переменной типа VALUE с полем данных в 4 байта с обязательной инициализацией значением со стека
  b                      \ имя переменной выдает содержимое переменной
  0  is b                \ присвоение значения переменной словом  is
  c!b  c  0  ib c        \ создание переменной типа VALUE в байт,    присвоение значения переменной словом  ib
  d!w  d  0  iw d        \ создание переменной типа VALUE в 2 байта, присвоение значения переменной словом  iw
  e!d  e  0. id e        \ создание переменной типа VALUE в 8 байт,  присвоение значения переменной словом  id
  0,0 v!f                \ создание переменной типа FVALUE в 8 байт, присвоение значения переменной словом  if
  10 arr]                \ создание статического массива размером в 10 байт
  $ 8 as}                \ создание статического массива размером в  8 байт  
  [ Q1 >CS ] ar}         \ создание статического массива размером в  6 байт
  as ( -- addr_as )      \ имя массива выдает адрес начала массива
  sqrt( $ -4 @P=A $ -4 0=@P 0SQRT $ -4 @P=0- $ -4 A=@P ) \ создание процедуры с использованием инструкций процессора
  3dup( 3/123123 )       \ создание процедуры с использованием манипуляторов
  p1( A++ DUP 2/12+ )    \ процедуру можно создавать со смешанным использованием ассемблера, форта и манипуляторов
  p2( p1 is b A-- /x )   \ в процедуре могут быть использованы ранее определенные локальные имена процедур
;
+: proc1 ... ;           \ процедура определенная через +: после процедуры с локальными именами может пользоваться не только своими локальными именами, но и 
                         \ локальными именами предыдущей процедуры
                         \ удаление лок. словаря производится по очередному слову  :

str1" 123                \ определение локально-именованной строки(многострочной), при исполнении str1 оставит на стеке a u строки '123 DUP'
       DUP "             \ внутри строки возможно использование коментариев типа '\'

+L[ 4 +LOOP ]            \ определение локально-именованного макроса, при использовании к лок. имени макроса нужно добавить суффикс немедленного исполнения  
12 0 DO I . +L`          \ +L` - пример использования лок.-именованного макроса

cl{ LITERAL DUP * }      \ определение функции-замыкания(closure), при исполнении 2 cl на стек будет положен XT, при исполнении которого на стеке будет 4,
                         \ при исполнении 3 cl на стек будет положен XT, при исполнении которого на стеке будет 9. 
                         \ Тоесть cl при каждом исполнении оставляет новый экземпляр кода, в котором будут замкнуты конкретные параметры(в приведенном случае 
                         \ они берутся со стека параметров). После N исполнений cl будет создано и сохранено N различных экземпляров кода

aDO( OVER + SWAP ` DO )  \ локально-именованные слова с использованием слов немедленного исполнения - определение 
2 0 aDO` I . LOOP        \ локально-именованные слова с использованием слов немедленного исполнения - исполнение
                         \ суффикс '`' используется как признак немедленного исполнения слова с таким суффиксом 

Примечание: внутри тела локальных слов использовать лок. слова и переменые можно, а создавать нельзя.
